
*************Message***************


package ca2_Ronan_Duffy_Michael_Grinnell_Final;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;


public class Message {

    private String fromAddress;
    private ArrayList <String> toAddress;
    private String subject;
    private ZonedDateTime dateSent ;
    private String priority;
    private String messageBody;
    private static long IDSeed = 1000;
    private long messageID;

    public Message(String from, ArrayList <String> to, String sub, ZonedDateTime date, String pri, String body) {
        fromAddress = from;
        toAddress = to;
        subject = sub;
        dateSent = date;
        priority = pri;
        messageBody = body;
        messageID = IDSeed;
        IDSeed++;
    }

    public void setMessageID(long messageID) {
        this.messageID = messageID;
    }

    public void setDateSent(ZonedDateTime dateSent) {
        this.dateSent = dateSent;
    }

    public void setFromAddress(String f) {
        fromAddress = f;
    }

    public String getFromAddress() {
        return fromAddress;
    }

    public ZonedDateTime getDateSent() {
        return dateSent;
    }

    public int getDateDay() {
        return dateSent.getDayOfMonth();
    }

    public int getDateMonth() {
        return dateSent.getMonthValue();
    }

    public int getDateYear() {
        return dateSent.getYear();
    }
    public int getDateHour() {
        return dateSent.getHour();
    }
    public int getDateMin() {
        return dateSent.getMinute();
    }

    public void setToAddress(String to) {
        toAddress.add(to);
    }

    public ArrayList <String> getToAddress() {        
        return toAddress;
    }
    public String getToFirstAddress() {        
        return toAddress.get(0);
    }

    public void setSubject(String sub) {
        subject = sub;
    }

    public String getSubject() {
        return subject;
    }

    public void setPriority(String p) {
        priority = p;
    }

    public String getPriority() {
        return priority;
    }

    public void setMessageBody(String m) {
        messageBody = m;
    }

    public String getMessageBody() {
        return messageBody;
    }

    public long getMessageID() {
        return messageID;
    }

    public String ViewMessage() {
        DateTimeFormatter dtf = DateTimeFormatter.RFC_1123_DATE_TIME ;
        String date = dtf.format(dateSent);
        String result = String.format("%-40s %-40s %-40s %-40s", "From : " + fromAddress, "To : " + toAddress, "\nPriority : " + priority, "Date : " + date + "\nSubject :" + subject + "\n\nMessage Content:\n" + messageBody + "\n");
        return result;
    }

    public String toInboxString() {
        DateTimeFormatter dtf = DateTimeFormatter.RFC_1123_DATE_TIME ;
        String date = dtf.format(dateSent);

        
        String result = String.format("%-40s %-40s %-10s", fromAddress, subject, date);
        return result;
    }

    public String toOutboxString() {
        DateTimeFormatter dtf = DateTimeFormatter.RFC_1123_DATE_TIME ;
        String date = dtf.format(dateSent);        

        String recipients = toAddress.toString();
        if (toAddress.size()> 2){
            recipients = toAddress.get(0)+ "," + toAddress.get(1) +"...";
        }
        
        String result = String.format("%-40s %-40s %-10s", recipients, subject, date);
        return result;
    }

    public String toAllString() {
        DateTimeFormatter dtf = DateTimeFormatter.RFC_1123_DATE_TIME ;
        String date = dtf.format(dateSent);       

                String recipients = toAddress.toString();
        if (toAddress.size()> 2){
            recipients = "[" +toAddress.get(0)+ "," + toAddress.get(1) +"...]";
        }
        String result = String.format("%-40s %-40s %-40s %-10s", fromAddress, recipients, subject, date);
        return result;
    }

    public String toFileString() {
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < toAddress.size(); i++) {
            out.append(toAddress.get(i)).append("::");
        }

        String recipients = out.toString();
        DateTimeFormatter dtf = DateTimeFormatter.RFC_1123_DATE_TIME ;
        String date = dtf.format(dateSent);
        return messageID + ";" + fromAddress + ";" + recipients + ";" + subject + ";" + getDateDay() + ";" + getDateMonth()  + ";" + getDateYear() + ";" + getDateHour() + ";" + getDateMin() + ";" + priority + ";" + messageBody;
    }

}


*************MessageStore***************



package ca2_Ronan_Duffy_Michael_Grinnell_Final;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import java.util.Scanner;

public class messageStore {

    private final ArrayList<Message> list;

    public messageStore() {
        list = new ArrayList<>();
    }

    public void addMessage(Message m) {
        list.add(m);
    }

    public ArrayList<Message> listMessageByKeyword(String key) {
        ArrayList<Message> found = new ArrayList<>();
        list.stream().filter((mail) -> (mail.getSubject().contains(key) || mail.getMessageBody().contains(key))).forEach((mail) -> {
            found.add(mail);
        });
        return found;
    }

    public ArrayList<Message> getMessagesPriority(String priority) {
        ArrayList<Message> found = new ArrayList<>();
        list.stream().filter((m) -> (m.getPriority().equals(priority))).forEach((m) -> {
            found.add(m);
        });
        return found;
    }

    public ArrayList<Message> getAllMessages() {
        return list;

    }

    public ArrayList<Message> getMessagesTo(String userEmail) {
        ArrayList<Message> found = new ArrayList<>();
        list.stream().filter((m) -> (m.getToAddress().contains(userEmail))).forEach((m) -> {
            found.add(m);
        });
        return found;
    }

    public ArrayList<Message> getMessagesDate(ZonedDateTime date) {
        ArrayList<Message> found = new ArrayList<>();
        for (Message m : list) {
            if ((m.getDateDay() == date.getDayOfMonth()) && (m.getDateMonth() == date.getMonthValue()) && (m.getDateYear() == date.getYear()) ) {
                found.add(m);
            }
        }
        return found;
    }

    public ArrayList<Message> getMessagesBetweenDate(ZonedDateTime after, ZonedDateTime before) {
        ArrayList<Message> found = new ArrayList<>();

        for (Message m : list) {
            if (m.getDateSent().isAfter(after) && m.getDateSent().isBefore(before)){
                found.add(m);
            }
        }
        return found;
    }

    public ArrayList<Message> getMessagesFromBetween(String email, ArrayList<Message> f) {
        ArrayList<Message> found = new ArrayList<>();
        f.stream().filter((m) -> (m.getFromAddress().equals(email))).forEach((m) -> {
            found.add(m);
        });
        return found;
    }

    public ArrayList<Message> getMessagesFrom(String userEmail) {
        ArrayList<Message> found = new ArrayList<>();
        list.stream().filter((m) -> (m.getFromAddress().equals(userEmail))).forEach((m) -> {
            found.add(m);
        });
        return found;
    }

    public Message returnMessageFromID(long id) {
        int index = 0;
        for (int i = 0; i < list.size(); i++) {

            if (list.get(i).getMessageID() == id) {
                index = i;

            }
        }
        return list.get(index);
    }

    public void saveNewMessageFile() throws FileNotFoundException {

        File file = new File("mailData/mailData.txt");
        try {
            FileWriter fw = new FileWriter(file.getAbsoluteFile());
            try (BufferedWriter bw = new BufferedWriter(fw)) {
                for (Message m : list) {
                    bw.write(m.toFileString());
                    bw.newLine();
                }
            }
            System.out.println("File " + file.getName() + " saved");
        } catch (IOException e) {
        }
    }

    public void loadNewMessageFile() throws FileNotFoundException {
        File file = new File("mailData/mailData.txt");
        String SplitBy = ";";
        if (!file.exists()) {
            System.out.println(file + " not found. Creating file.");
            try {
                FileWriter fw = new FileWriter(file.getAbsoluteFile());
                try (BufferedWriter bw = new BufferedWriter(fw)) {
                    bw.write("1000;dummy@theFarm.org;dummy@theFarm.org;Welcome;1;1;2016;High;This is a dummy message since there was no mailData.txt file. Delete this when possible.");
                }
                System.out.println("File successfully created");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try (Scanner in = new Scanner(file)) {
            ZonedDateTime date;
            long id;
            ArrayList <String> recipients;
            while (in.hasNextLine()) {
                //date = new int[3];
                recipients = new ArrayList<>();
                String line = in.nextLine();
                String[] messageDetails = line.split(SplitBy);
                
                int day = Integer.parseInt(messageDetails[4]);
                int month = Integer.parseInt(messageDetails[5]);
                int year = Integer.parseInt(messageDetails[6]);
                int hour = Integer.parseInt(messageDetails[7]);
                int min = Integer.parseInt(messageDetails[8]);
                date = ZonedDateTime.of(year, month, day, hour, min, 0, 0, ZoneId.of("Europe/Dublin"));
                String[] recipient = messageDetails[2].split("::");
                recipients.addAll(Arrays.asList(recipient));
                
                Message m = new Message(messageDetails[1],recipients, messageDetails[3], date, messageDetails[9], messageDetails[10]);
                m.setDateSent(date);
                m.setMessageID(Long.parseLong(messageDetails[0]));
                list.add(m);
            }
            System.out.println("File " + file.getName() + " read");
            in.close();
        }
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 97 * hash + Objects.hashCode(this.list);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final messageStore other = (messageStore) obj;
        return Objects.equals(this.list, other.list);
    }

}


*************Employee***************

package ca2_Ronan_Duffy_Michael_Grinnell_Final;

import java.util.Arrays;
import java.util.Objects;

/**
 *
 * @author Michael
 */
public class Employee {

    private String name;
    private static long uniqueId = 1;
    private long id;
    private String phoneNum;
    private final int birthDate[] = new int[3];
    private String emailAddress;
    private String password;
    private boolean admin;

    public Employee(String name, String phoneNum, String emailAddress) {
        this.name = name;
        this.phoneNum = phoneNum;
        this.emailAddress = emailAddress;
        id = uniqueId;
        uniqueId++;
        admin = true;

    }

    public boolean isAdmin() {
        return admin;
    }
    public void setAdmin(boolean a) {
        admin = a;
    }

    public long getId() {
        return id;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPassword() {
        return password;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setEmpId(long id) {
        this.id = id;
    }

    public void setPhoneNum(String phoneNum) {
        this.phoneNum = phoneNum;
    }

    public String getPhoneNum() {
        return phoneNum;
    }

    public void setBirthDate(int i, int date) {
        birthDate[i] = date;
    }

    public int[] getBirthDate() {
        return birthDate;
    }

    public int getDateDay() {
        return birthDate[0];
    }

    public int getDateMonth() {
        return birthDate[1];
    }

    public int getDateYear() {
        return birthDate[2];
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public String getEmailAddress() {
        return emailAddress;
    }
    
    public String getEmployeeType() {
        return "Employee";
    }
    public String getSalary() {
        return "Don't use this";
    }
    @Override
    public String toString() {

        String birthString = birthDate[0] + "//" + birthDate[1] + "//" + birthDate[2];
        return "\n\nEmployee ID :\t " + id + "\nName :\t" + name + " \nBirthdate :\t" + birthString + "\nEmail Address :\t" + emailAddress + "\nPhone Number :\t" + phoneNum;
    }

    public String toStringNoSal() {

        String birthString = birthDate[0] + "//" + birthDate[1] + "//" + birthDate[2];
        return "\n\nEmployee ID :\t " + id + "\nName :\t" + name + " \nBirthdate :\t" + birthString + "\nEmail Address :\t" + emailAddress + "\nPhone Number :\t" + phoneNum;
    }
    
    public String toFileString() {
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < 3; i++) {
            out.append(birthDate[i]).append(";");
        }
        String birthString = out.toString();
        String finalString = id + ";" + name + ";" + phoneNum + ";" + emailAddress + ";" + birthString + password + ";" + admin;
        return finalString;
    }

    public String toListString() {

        String birthString = birthDate[0] + "//" + birthDate[1] + "//" + birthDate[2];

        String result = String.format("%-6s %-30s %-20s %-40s %-40s", id, name, birthString, emailAddress, phoneNum);
        return result;
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 89 * hash + Objects.hashCode(this.name);
        hash = 89 * hash + (int) (this.id ^ (this.id >>> 32));
        hash = 89 * hash + Objects.hashCode(this.phoneNum);
        hash = 89 * hash + Arrays.hashCode(this.birthDate);
        hash = 89 * hash + Objects.hashCode(this.emailAddress);
        hash = 89 * hash + Objects.hashCode(this.password);
        hash = 89 * hash + (this.admin ? 1 : 0);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Employee other = (Employee) obj;
        if (this.id != other.id) {
            return false;
        }
        if (this.admin != other.admin) {
            return false;
        }
        if (!Objects.equals(this.name, other.name)) {
            return false;
        }
        if (!Objects.equals(this.phoneNum, other.phoneNum)) {
            return false;
        }
        if (!Objects.equals(this.emailAddress, other.emailAddress)) {
            return false;
        }
        if (!Objects.equals(this.password, other.password)) {
            return false;
        }
        if (!Arrays.equals(this.birthDate, other.birthDate)) {
            return false;
        }
        return true;
    }

}



*************EmployeeStore***************

package ca2_Ronan_Duffy_Michael_Grinnell_Final;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;


public class Employee_store {

    private final ArrayList<Employee> employeeList;
    private final ArrayList<Agent> agentList;
    private final ArrayList<Contractor> contractorList;
    
   // temparary string array to store email addresses for messages with multiple recipients
    private final ArrayList<String> mailList;

    public Employee_store() {
        employeeList = new ArrayList<>();
        mailList = new ArrayList<>();
        agentList = new ArrayList<>();
        contractorList = new ArrayList<>();
        
    }
    //--------------------------------------------Return Details------------------------------------------------

    public String displayEmployees() {
        return employeeList.toString();
    }

    public ArrayList<Employee> getAllEmployees() {
        return employeeList;
    }

    public String displayEmployee(Employee e) {
        return e.toString();
    }

    public String addToMailList(String address) {
        mailList.add(address);
        return address + " has been added to mailing list";
    }

    public ArrayList<String> getMailList() {
        return mailList;
    }

    //--------------------------------------------Add Details------------------------------------------------
    // Add Employee From user Input Method  
    public String addEmployee() {
        Scanner in = new Scanner(System.in);       
        boolean agent = addEmpType();//Determine the type of employee
        String name = addName();
        String phoneNum = addPhone();
        String emailAddress = addEmail(employeeList);
        String Password = "Cheese";
        String newEmpDetails;
                                    
        if(agent) {
                Agent a = new Agent(name, phoneNum, emailAddress);
                double salary = addSalary();
                a.setSalery(salary);
                addBirthDate(a);
                a.setPassword(Password);
                employeeList.add(a);
                agentList.add(a);
                newEmpDetails = a.toString();
                
            } else {
                Contractor c = new Contractor(name, phoneNum, emailAddress);
                double hourWork = addHoursWorked();
                c.setHoursWorked(hourWork);
                double rate = addHourlyRate();
                c.setHourlyRate(rate);
                addBirthDate(c);
                c.setPassword(Password);
                c.setAdmin(false);
                employeeList.add(c);
                contractorList.add(c);
                newEmpDetails = c.toString();
                               
            }    
        System.out.println("Employee succsessfully added, You will be returned to the admin menu.");
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException ex) {
            Logger.getLogger(TheFarmLtd_Main.class.getName()).log(Level.SEVERE, null, ex);
        }
        return newEmpDetails;
    }

    
    public boolean addEmpType(){
        System.out.println("(1)Agent (2)Contractor");
        boolean isAgent = true;
        Scanner in = new Scanner(System.in);
        if (!in.hasNextInt()){
            System.out.println("Not a valid option");
            addEmpType();
        }
        else{
            switch(in.nextInt()){
            case 1 :
            isAgent = true;
            break;
            case 2 :
            isAgent = false;
            break;
            default :
            System.out.println("Not a valid choice");
            addEmpType();
            break;
        }
        }
        return isAgent;
    }
    
    public ArrayList<Employee> getAgents(){
        ArrayList<Employee> found = new ArrayList<>();
                for (int i = 0; i < employeeList.size(); i++) {
            if (employeeList.get(i).getEmployeeType().equals("Agent")) // employeeList.get(i)  instanceof Agent
            {               
                found.add(employeeList.get(i));
            }
            
        }
                return found;
    }

    public String addEmail(ArrayList<Employee> employeeList) {
        Scanner in = new Scanner(System.in);
        boolean unique;
        String finalEmail;
        System.out.println("Please enter Employee Email wich will then be appended with @theFarm.org");
        do {
            String emailAddress = in.next();
            finalEmail = appendEmail(emailAddress);
            unique = checkEmailUnique(finalEmail);

            if (!unique) {
                System.out.println("Email address already in use, Please try a different email");
            }
        } while (!unique);

        return finalEmail;
    }

    public String addName() {
        Scanner in = new Scanner(System.in);
        boolean valid = false;
        String name = "";
        System.out.println("Please enter Employee name");

        while (valid == false) {
            name = in.nextLine();
            valid = isOnlyLetters(name);

            if (!valid) {
                System.out.println("Sorry the field 'Name' can only contain letters, please try again");
            }
        }

        return name;
    }

    public String addPhone() {
        Scanner in = new Scanner(System.in);
        boolean valid = false;
        String phoneNum = "";
        System.out.println("Please enter Employee Phone");

        while (valid == false) {
            phoneNum = in.next();
            valid = isOnlyNumbers(phoneNum);

            if (!valid) {
                System.out.println("Sorry A phone number can only contain numbers with a positive value");
            }
        }

        return phoneNum;
    }

    // Adds birth date to an array of 3 ints for day/month/year
    public void addBirthDate(Employee e) {
        Scanner in = new Scanner(System.in);
        int date = 0;
        boolean valid;
        System.out.println("Please enter Employee BirthDate.\n");
        for (int i = 0; i < 3; i++) {

            do {
                if (i == 0) {
                    System.out.print("Day :");
                }
                if (i == 1) {
                    System.out.print("Month :");
                }
                if (i == 2) {
                    System.out.print("Year :");
                }
                if (!in.hasNextInt()) {
                    System.out.println("Not A Valid Date");
                    in.next();
                    valid = valiDate(i, 999);
                } else {
                    date = in.nextInt();
                    valid = valiDate(i, date);
                }

            } while (!valid);

            e.setBirthDate(i, date);
        }
    }

    public double addSalary() {
        Scanner in = new Scanner(System.in);        
        double salary = 0;      
            while (true) {
            System.out.println("What's this agent's salary?");
            try {
                salary = Double.parseDouble(in.next());
                if (salary < 0) {
                System.out.println("You can't have negative salary");
                addSalary();
                break;
                }
                else{
                break;} 
            } catch (NumberFormatException ignore) {
                System.out.println("Not a valid option");
            }
        }                       
        return salary;
    }

    public double addHoursWorked() {
        Scanner in = new Scanner(System.in);
        double hours = 0;
        while (true) {
        System.out.println("How many hours has this contractor worked?");
        try {
                hours = Double.parseDouble(in.next());
                if (hours < 0) {
                System.out.println("You can't have negative hours");
                addHoursWorked();
                break;
                }
                else{
                break;} 
            } catch (NumberFormatException ignore) {
                System.out.println("Not a valid option");
            }
        }
        return hours;
    }

    public double addHourlyRate() {
        Scanner in = new Scanner(System.in);
        boolean valid = false;
        double rate = 0;
        
                while (true) {
        System.out.println("What is this contractor hourly rate?");
        try {
                rate = Double.parseDouble(in.next());
                if (rate < 0) {
                System.out.println("You can't have negative rate");
               addHourlyRate();
                break;
                }
                else{
                break;} 
            } catch (NumberFormatException ignore) {
                System.out.println("Not a valid option");
            }
                }
        return rate;
    }

    public String setPassword(Long id) {
        Scanner in = new Scanner(System.in);
        boolean valid = false;
        String password;
        String customMessege = "";

        while (valid == false) {
            System.out.println("Please enter your new Password, your new password must be longer than five characters and less than ten.");
            password = in.next();

            if (password.length() < 5 || password.length() > 10) {
                System.out.println("Sorry, your password must be longer than five characters and less than ten.");
            } else {
                System.out.println("Please confirm your new password");
                String passwordConfirm = in.next();

                if (passwordConfirm.equals(password)) {
                    FindEmpById(id).setPassword(password);
                    customMessege = "Your password has been changed to " + FindEmpById(id).getPassword();
                    valid = true;
                } else {
                    System.out.println("Your passwords did not match please try again");
                }
            }
        }
        return customMessege;
    }

    //--------------------------------------------Search Details------------------------------------------------       
    // Search for employee by name
    public ArrayList<Employee> FindName(String empName) {
        ArrayList<Employee> employeesFoundByName = new ArrayList<>();
        String checkName;
        String searchName = empName.toLowerCase().replaceAll("[']", "");
        for (int i = 0; i < employeeList.size(); i++) {

            checkName = employeeList.get(i).getName().toLowerCase().replaceAll("[\\s\\']", "");

            if (checkName.equals(searchName)) {
                employeesFoundByName.add(employeeList.get(i));
            } else if (!checkName.equals(searchName)) {
                int searchSize;
                int foundLetters = 0;
                if (checkName.length() >= searchName.length()) {
                    searchSize = searchName.length();
                } else {
                    searchSize = checkName.length();
                }
                for (int j = 0; j < searchSize; j++) {
                    if (searchName.charAt(j) == checkName.charAt(j)) {
                        foundLetters++;
                    } else {
                        foundLetters = 0;
                    }
                    if (foundLetters >= 4) {
                        employeesFoundByName.add(employeeList.get(i));
                        break;
                    }
                }
            }
        }
        return employeesFoundByName;
    }

    public Employee FindEmpByEmail(String email) {
        int found = -1;
        for (int i = 0; i < employeeList.size(); i++) {

            if (employeeList.get(i).getEmailAddress().equals(email)) {
            }
            found = i;
        }
        return employeeList.get(found);
    }

    public Employee FindEmpById(long id) {
        int found = -1;
        for (int i = 0; i < employeeList.size(); i++) {

            if (employeeList.get(i).getId() == (id)) {
                found = i;
            }

        }
        return employeeList.get(found);
    }

    public ArrayList<Employee> FindEmpByPhone(String phone) {
        ArrayList<Employee> employeesFound = new ArrayList<>();

        employeeList.stream().filter((e) -> (e.getPhoneNum().equals(phone))).forEach((e) -> {
            employeesFound.add((e));
        });

        return employeesFound;
    }
    
    public String listSalaries() {
        System.out.println("Now displaying monthly salaries for each employee");
        String list = "";
        
        for (int i = 0; i < employeeList.size(); i++) {
            list = list + "\n" + String.format("%-20s %-8s", employeeList.get(i).getName(), "€" + employeeList.get(i).getSalary());//employeeList.get(i).getName() + "\t\t" + employeeList.get(i).getSalary();
            
        }
        return list;
    }
        
    public String getTotalsalery(){
    double total = 0;
    
        for (Agent a : agentList) {
            total += a.getWages();
        }
        
        for (Contractor c : contractorList) {
            total += c.getWages();
        }
        String roundTotal = String.format("%.2f", total);
        return "€" +roundTotal;
    }

    //--------------------------------------------Edit Details------------------------------------------------
    public String editEmployeeName(long id) {
        String newName = addName();
        String oldName = FindEmpById(id).getName();
        String customMessege = "\nEmployee : " + oldName + " has been updated to : " + newName;
        FindEmpById(id).setName(newName);
        return customMessege;
    }

    public String editEmployeePhone(long id) {
        String newPhone = addPhone();
        String oldPhone = FindEmpById(id).getPhoneNum();
        String customMessege = "\nEmployee Phone number : " + oldPhone + " has been updated to : " + newPhone;
        FindEmpById(id).setPhoneNum(newPhone);
        return customMessege;
    }

    public String editEmployeeEmail(long id) {
        String newEmail = addEmail(employeeList);
        String old = FindEmpById(id).getPhoneNum();
        String customMessege = "\nEmployee Email Address : " + old + " has been updated to " + newEmail;
        FindEmpById(id).setEmailAddress(newEmail);
        return customMessege;
    }

    public String editEmployeeBirthDate(long id) {
        int[] old = FindEmpById(id).getBirthDate();
        String oldDate = old[0] + "/" + old[1] + "/" + old[2];

        addBirthDate(FindEmpById(id));

        int[] newBirthdate = FindEmpById(id).getBirthDate();

        String customMessege = "\nEmployee birthday : " + oldDate
                + " has been updated to " + newBirthdate[0] + "/" + newBirthdate[1] + "/" + newBirthdate[2];

        return customMessege;
    }
        public String editAgentSalery(long id) {
        System.out.println("Please Enter Agents New Salery");
        double newSal = addSalary();
        double oldSal= 0;
        Agent b = null;
        for (Agent a : agentList) {
            if (a.getId() == id){
                oldSal = a.getWages();
                a.setSalery(newSal);
                b=a;               
            }
        }
        for (int i = 0; i < employeeList.size(); i++) {
            if (employeeList.get(i).getId() == id){
                 employeeList.set(i,b);
            }
        }       
        String customMessege = "\nEmployee Salery : " + String.format("%.2f", oldSal) + " has been updated to " + String.format("%.2f", newSal);

        return customMessege;
    }
        
    public String editContractorRate(long id) {
        System.out.println("Please Enter Contractors New Rate");
        Contractor b = null;
        double newRate = addHourlyRate();
        double oldRate= 0;
        for (Contractor c : contractorList) {
            if (c.getId() == id){
                oldRate = c.getHourlyRate();
                c.setHourlyRate(newRate);
                b=c;
            }
        }
        for (int i = 0; i < employeeList.size(); i++) {
            if (employeeList.get(i).getId() == id){
                 employeeList.set(i,b);
            }
        }
        
        String customMessege = "\nEmployee Hourly Rate : " + String.format("%.2f", oldRate) + " has been updated to " + String.format("%.2f", newRate);

        return customMessege;
    }
    public String editContractorHours(long id) {
        System.out.println("Please Enter Contractors New Hours");
        Contractor b = null;
        double newHours = addHoursWorked();
        double oldHours= 0;
        for (Contractor c : contractorList) {
            if (c.getId() == id){
                oldHours = c.getHourlyRate();
                c.setHourlyRate(newHours);
                b=c;
            }
        }
        for (int i = 0; i < employeeList.size(); i++) {
            if (employeeList.get(i).getId() == id){
                 employeeList.set(i,b);
            }
        }
          
        String customMessege = "\nEmployee Hours Worked : " + String.format("%.2f", oldHours) + " has been updated to " + String.format("%.2f", newHours);

        return customMessege;
    }

    public String delEmployee(long id) {
        Scanner in = new Scanner(System.in);
        String customMessege = "";
        for (int i = 0; i < employeeList.size(); i++) {

            if (employeeList.get(i).getId() == id) {
                System.out.println("Are you sure you wish to remove " + employeeList.get(i).getName() + "\nId #" + employeeList.get(i).getId() + "\t Y/N");

                if (in.next().equalsIgnoreCase("y")) {
                    customMessege = "\nemployee : " + employeeList.get(i).getName() + "\nId #" + employeeList.get(i).getId()
                            + "\nHas been removed";
                    employeeList.remove(i);

                } else {
                    customMessege = "\nemployee : " + employeeList.get(i).getName() + "\nId #" + employeeList.get(i).getId()
                            + "\nHas NOT been removed";
                }
            }
        }
        return customMessege;
    }

    //--------------------------------------------Validate------------------------------------------------
    public static String appendEmail(String email) {
        StringBuilder out = new StringBuilder();
        out.append(email).append("@theFarm.org");
        return out.toString();
    }

    public boolean isOnlyNumbers(String word) {
        char[] chars = word.toCharArray();

        for (char c : chars) {
            if (!Character.isDigit(c) || Character.getNumericValue(c) < 0) {
                return false;
            }
        }

        return true;
    }

    public static boolean isOnlyLetters(String w) {
        String word = w.replaceAll("[\\s\\']", "");

        char[] chars = word.toCharArray();

        for (char c : chars) {
            if (!Character.isLetter(c)) {
                return false;
            }
        }

        return true;
    }

    public boolean checkIdExists(long id) {
        boolean exists = false;

        for (int i = 0; i < employeeList.size(); i++) {
            if (employeeList.get(i).getId() == (id)) {
                exists = true;
            }

        }
        return exists;
    }

    public boolean checkEmailUnique(String eMAddress) {
        boolean unique = true;
        for (Employee e : employeeList) {
            if (e.getEmailAddress().equals(eMAddress)) {
                unique = !unique;
            }
        }

        return unique;
    }

    //Validate date
    public boolean valiDate(int i, int date) {
        boolean valid = true;
        if (i == 0 && (date < 1 || date > 31)) {
            valid = false;
            System.out.println("please enter a valid date");
        } else if (i == 1 && (date < 1 || date > 12)) {
            valid = false;
            System.out.println("please enter a valid date");
        } else if (i == 2 && (date < 1900 || date > 2017)) {
            valid = false;
            System.out.println("please enter a valid date");
        }

        return valid;
    }

    //--------------------------------------------save and load to file------------------------------------------------
    public void saveNewFile() throws FileNotFoundException {

        //File file = new File("empData/empData.txt");
        File fileAgent = new File("empData/agentData.txt");
        File fileContract = new File("empData/conData.txt");
        try {

            FileWriter fwA = new FileWriter(fileAgent.getAbsoluteFile());
            try (BufferedWriter bwA = new BufferedWriter(fwA)) {
                for (Employee e : employeeList) {
                    if (e.getEmployeeType().equals("Agent")) {
                        bwA.write(e.toFileString());
                        bwA.newLine();
                    }

                }
            }

            System.out.println("File " + fileAgent.getName() + " saved");

        } catch (IOException e) {
        }
        try {

            FileWriter fwC = new FileWriter(fileContract.getAbsoluteFile());
            try (BufferedWriter bwC = new BufferedWriter(fwC)) {
                for (Employee e : employeeList) {
                    if (e.getEmployeeType().equals("Contractor")) {
                        bwC.write(e.toFileString());
                        bwC.newLine();
                    }
                }
            }

            System.out.println("File " + fileContract.getName() + " saved");

        } catch (IOException e) {
        }

    }

    public void loadNewFile() throws FileNotFoundException {

        
        File fileAgent = new File("empData/agentData.txt");
        File fileContract = new File("empData/conData.txt");
        String SplitBy = ";";
        //Check if both files exists. If not, create them
        if (!fileAgent.exists()) {
            System.out.println(fileAgent + " not found. Creating file.");
            try {
                FileWriter fwA = new FileWriter(fileAgent.getAbsoluteFile());
                try (BufferedWriter bwA = new BufferedWriter(fwA)) {
                    bwA.write("1;Dummy;08452856;dummy@theFarm.org;12;6;1924;Cheese;true;200");
                }
                System.out.println("File successfully created");
            } catch (IOException e) {

            }
        }
        if (!fileContract.exists()) {
            System.out.println(fileContract + " not found. Creating file.");
            try {
                FileWriter fwC = new FileWriter(fileContract.getAbsoluteFile());
                try (BufferedWriter bwC = new BufferedWriter(fwC)) {
                    bwC.write("2;Dummy2;08451924;dummy@theFarm.org;12;6;1924;Cheese;false;13;50");
                }
                System.out.println("File successfully created");
            } catch (IOException e) {

            }
        }
        try (Scanner in = new Scanner(fileAgent)) {

            while (in.hasNextLine()) {
                String line = in.nextLine();
                String[] EmployeeDetails = line.split(SplitBy);
                Agent e = new Agent(EmployeeDetails[1], EmployeeDetails[2], EmployeeDetails[3]);
                e.setEmpId(Long.parseLong(EmployeeDetails[0]));
                e.setBirthDate(0, Integer.parseInt(EmployeeDetails[4]));
                e.setBirthDate(1, Integer.parseInt(EmployeeDetails[5]));
                e.setBirthDate(2, Integer.parseInt(EmployeeDetails[6]));
                e.setPassword(EmployeeDetails[7]);
                e.setAdmin(Boolean.parseBoolean(EmployeeDetails[8]));
                e.setSalery(Double.parseDouble(EmployeeDetails[9]));
                employeeList.add(e);
                agentList.add(e);               

            }
            System.out.println("File " + fileAgent.getName() + " read");
            in.close();

        }
        try (Scanner in = new Scanner(fileContract)) {

            while (in.hasNextLine()) {
                String line = in.nextLine();
                String[] EmployeeDetails = line.split(SplitBy);
                Contractor e = new Contractor(EmployeeDetails[1], EmployeeDetails[2], EmployeeDetails[3]);
                e.setEmpId(Long.parseLong(EmployeeDetails[0]));
                e.setBirthDate(0, Integer.parseInt(EmployeeDetails[4]));
                e.setBirthDate(1, Integer.parseInt(EmployeeDetails[5]));
                e.setBirthDate(2, Integer.parseInt(EmployeeDetails[6]));
                e.setPassword(EmployeeDetails[7]);
                e.setAdmin(Boolean.parseBoolean(EmployeeDetails[8]));
                e.setHoursWorked(Double.parseDouble(EmployeeDetails[9]));
                e.setHourlyRate(Double.parseDouble(EmployeeDetails[10]));
                employeeList.add(e);                
                contractorList.add(e);

            }
            System.out.println("File " + fileContract.getName() + " read");
            in.close();

        }

    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 29 * hash + Objects.hashCode(this.employeeList);
        hash = 29 * hash + Objects.hashCode(this.agentList);
        hash = 29 * hash + Objects.hashCode(this.contractorList);
        hash = 29 * hash + Objects.hashCode(this.mailList);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Employee_store other = (Employee_store) obj;
        if (!Objects.equals(this.employeeList, other.employeeList)) {
            return false;
        }
        if (!Objects.equals(this.agentList, other.agentList)) {
            return false;
        }
        if (!Objects.equals(this.contractorList, other.contractorList)) {
            return false;
        }
        return Objects.equals(this.mailList, other.mailList);
    }

}



*************Agent***************

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca2_Ronan_Duffy_Michael_Grinnell_Final;

/**
 *
 * @author Michael
 */
public class Agent extends Employee {

    double salery;
    //private boolean admin = true;
    public Agent(String name, String phoneNum, String emailAddress) {
        super(name, phoneNum, emailAddress);
        salery = 0;
    }
    
    public Agent(String name, String phoneNum, String emailAddress, double sal) {
        super(name, phoneNum, emailAddress);
        salery = sal;
    }

    public double getWages() {
        return salery;
    }

    public void setSalery(double salery) {
        this.salery = salery;
    }
    @Override
    public String getSalary() {
        String roundSalery = String.format("%.2f", salery);
        return roundSalery;
    }
    @Override
    public String toString() {
        String roundSalery = String.format("%.2f", salery);
        return "Agent\n" + super.toString() + "\nSalery : " + roundSalery;
    }
        

    
    @Override
    public String toListString() {
        return super.toListString() + "Agent";
    }
     
    @Override
    public String getEmployeeType() {
        return "Agent";
    }

    @Override
    public String toFileString() {
        return super.toFileString() + ";" + salery;
    }
    
    
}


*************Contractor***************

package ca2_Ronan_Duffy_Michael_Grinnell_Final;


public class Contractor extends Employee {
    private double hoursWorked;
    private double hourlyRate;
    //private boolean admin = false;

    public Contractor(String name, String phoneNum, String emailAddress) {
        super(name, phoneNum, emailAddress);
    }

    public double getHoursWorked() {
        return hoursWorked;
    }

    public void setHoursWorked(double hoursWorked) {
        this.hoursWorked = hoursWorked;
    }

    public double getHourlyRate() {
        return hourlyRate;
    }
    public double getWages(){
        return hourlyRate * hoursWorked;
    }

    public void setHourlyRate(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }
    @Override
    public String getSalary() {
        String roundSal= String.format("%.2f", (hoursWorked * hourlyRate));
        return roundSal;
    }
    
    
    @Override
    public String toString() {
        String roundHours = String.format("%.2f", hoursWorked);
        String roundRate = String.format("%.2f", hourlyRate);
        return "Contractor\n" + super.toString() + "\nHours Worked : " + roundHours + "\nHourly Rate : " + roundRate + "\nTotal Wages : " + (hoursWorked * hourlyRate);
    }
        
    
        
    @Override
     public String toListString() {
         return super.toListString() + "Contractor";
     }
     
    @Override
    public String getEmployeeType() {
        return "Contractor";
    }

    @Override
    public String toFileString() {
        return super.toFileString() + ";" + hoursWorked + ";" + hourlyRate;
    }
    
    
}


*************Main***************

package ca2_Ronan_Duffy_Michael_Grinnell_Final;
import java.io.File;
import java.io.FileNotFoundException;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class TheFarmLtd_Main {

    public static void main(String[] args) throws FileNotFoundException {
        mainMenu("\nPlease Log in.");
    }
    
    //--------------------------------------------Main Menu (Login)------------------------------------------------
    public static void mainMenu(String customMessege) throws FileNotFoundException {
        Employee_store employeeStoreList = new Employee_store();
        messageStore mailServer = new messageStore();
        employeeStoreList.loadNewFile();
        mailServer.loadNewMessageFile();

        Employee currentUser;
        boolean idExists;
        String warMessege = "";

        Scanner in = new Scanner(System.in);
        System.out.println("*******************************************"
                + "\n_  _ ____ _ _  _    _  _ ____ _  _ _  _ "
                + "\n|\\/| |__| | |\\ |    |\\/| |___ |\\ | |  |"
                + "\n|  | |  | | | \\|    |  | |___ | \\| |__|"
                + "\n                                       "
                + "\n*******************************************\n"
                + customMessege
        );
        
        System.out.print("ID : ");
        if (!in.hasNextLong()) {
            mainMenu("Not a valid ID");
        } 
        else {
            long id = in.nextLong();
            System.out.print("Password : ");
            String password = in.next();
            idExists = employeeStoreList.checkIdExists(id);
            
            if (idExists) {
                currentUser = employeeStoreList.FindEmpById(id);
                
                if (password.equals(currentUser.getPassword())) {

                    if (password.equals("Cheese")) {
                        warMessege = "Warning, You are using the default password. Please change your Password. ";
                    }
                    if (currentUser.isAdmin()) {
                        adminMenu("\n\nWelcome " + currentUser.getName() + ".\nWhat would you like to do today?\n" + warMessege, employeeStoreList, currentUser, mailServer);
                    } else {
                        userMenu("\n\nWelcome " + currentUser.getName() + ".\nWhat would you like to do today?\n" + warMessege, employeeStoreList, currentUser, mailServer);
                    }
                } else {
                    mainMenu("\nLogin failed - Password Incorrect.");
                }
            } else {
                mainMenu("\nLogin failed - Id not valid.");
            }
        }
    }

    //--------------------------------------------Administrator Menu------------------------------------------------
    public static void adminMenu(String customMessege, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        employeeStoreList.saveNewFile();
        Scanner in = new Scanner(System.in);
        boolean valid = true;
        
        System.out.println("********************************************"
                + "\n____ ___  _  _ _ _  _    _  _ ____ _  _ _  _ "
                + "\n|__| |  \\ |\\/| | |\\ |    |\\/| |___ |\\ | |  | "
                + "\n|  | |__/ |  | | | \\|    |  | |___ | \\| |__| "
                + "\n                                             "
                + "\n********************************************\n"
                + customMessege
                + "\n\n(1)Add Employee\n(2)Search Employee\n(3)See Salery for All Employees\n(4)Show Mailing List\n(5)Search All Mail\n(6)User Menu\n(7)Exit\n");
        
        int choice;
        if (!in.hasNextInt()) {
            adminMenu("Not A Valid Choice", employeeStoreList, currentUser, mailServer);
        } 
        else {
            choice = in.nextInt();
            switch (choice) {
                case 1:
                    customMessege = employeeStoreList.addEmployee();
                    employeeStoreList.saveNewFile();
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    searchEmp(employeeStoreList, currentUser, mailServer);
                    break;
                case 7:
                    employeeStoreList.saveNewFile();
                    confirmExit(employeeStoreList, currentUser, mailServer);
                    break;
                case 4:
                    customMessege = "\n Current Mailing list " + employeeStoreList.getMailList();
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 6:
                    customMessege = "\nAdministrator";
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 5:
                    searchMail(employeeStoreList, currentUser, mailServer);
                    break;
                case 3:
                    customMessege = employeeStoreList.listSalaries() + "\nTotal Salery for all Employees : " + employeeStoreList.getTotalsalery();
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                default:
                    customMessege = "\nI'm sorry, I didn't quite get that, please try again";
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
            }
        }
    }
    //--------------------------------------------User Menu------------------------------------------------

    public static void userMenu(String customMessege, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        boolean valid = true;
        System.out.println("********************************************"
                + "\n_  _ ____ ____ ____    _  _ ____ _  _ _  _ "
                + "\n|  | [__  |___ |__/    |\\/| |___ |\\ | |  | "
                + "\n|__| ___] |___ |  \\    |  | |___ | \\| |__| "
                + "\n                                           "
                + "\n********************************************\n"
                + customMessege);
        
        if (currentUser.isAdmin()) {
            System.out.print("\n(1)New messege\n(2)Inbox\n(3)Outbox\n(4)Search\n(5)Show Mailing List\n(6)Change Password\n(7)Exit\n(8)Admin Menu\n");
        } 
        else {
            System.out.println("\n(1)New messege\n(2)Inbox\n(3)Outbox\n(4)Search\n(5)Show Mailing List\n(6)Change Password\n(7)Exit\n");
        }
        if (!in.hasNextInt()) {
            userMenu("Not A Valid Choice", employeeStoreList, currentUser, mailServer);
        } 
        else {
            int choice = in.nextInt();
            switch (choice) {
                case 1:
                    getRecipient(employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    int displayOption = 1;
                    int sort = 0;
                    mailFound(mailServer.getMessagesTo(currentUser.getEmailAddress()), "Inbox", displayOption, employeeStoreList, mailServer, currentUser, sort);
                    break;
                case 3:
                    displayOption = 2;
                    sort = 0;
                    mailFound(mailServer.getMessagesFrom(currentUser.getEmailAddress()), "OutBox", displayOption, employeeStoreList, mailServer, currentUser, sort);
                    break;
                case 4:
                    searchEmp(employeeStoreList, currentUser, mailServer);
                    break;
                case 5:
                    customMessege = "\n Current Mailing list " + employeeStoreList.getMailList();
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 7:
                    confirmExit(employeeStoreList, currentUser, mailServer);
                    break;
                case 6:
                    customMessege = employeeStoreList.setPassword(currentUser.getId());
                    employeeStoreList.saveNewFile();
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 8:
                    if (currentUser.isAdmin()) {
                        adminMenu("\n\nWelcome " + currentUser.getName(), employeeStoreList, currentUser, mailServer);
                    } 
                    else {
                        customMessege = "\n'Im sorry, I didn't quite get that, please try again";
                        userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    }
                    break;
                default:
                    customMessege = "\nI'm sorry, I didn't quite get that, please try again";
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
            }
        }
    }

    //--------------------------------------------Search Employee Menu------------------------------------------------
    public static void searchEmp(Employee_store list, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("How would you like to search for employee"
                + "\n(1)Name, (2)Id, (3)Phone number, (4)E-mail, (5)Display All Employees, (6)Display Agents only, (7) Go Back");
        
        if (!in.hasNextInt()) {
            System.out.println("Not A Valid Choice");
            searchEmp(list, currentUser, mailServer);
        } 
        else {
            switch (in.nextInt()) {
                case 1:
                    searchEmpName(list, currentUser, mailServer);
                    break;
                case 2:
                    searchEmpId(list, currentUser, mailServer);
                    break;
                case 3:
                    searchEmpPhone(list, currentUser, mailServer);
                    break;
                case 4:
                    searchEmpEmail(list, currentUser, mailServer);
                    break;
                case 5:
                    manyEmpsFound(list.getAllEmployees(), list, currentUser, mailServer, 0, "Employees Found");
                    break;
                case 6:
                    manyEmpsFound(list.getAgents(), list, currentUser, mailServer, 0, "Agents Found");
                    break;
                case 7:
                    if (currentUser.isAdmin()) {
                        adminMenu("\nTotal Salery for all Employees : ", list, currentUser, mailServer);
                    } else {
                        userMenu("\nYou have been returned to the User menu", list, currentUser, mailServer);
                    }
                    break;
                default:
                    System.out.println("\nIm sorry, I didnt quite get that, please try again");
                    break;
            }
        }
    }
    //--------------------------------------------Employee found Menu------------------------------------------------

    public static void empFound(Employee e, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        String customMessege;
        
        if (currentUser.isAdmin()) {
            System.out.println("\nEmployee found,"
                    + "\t\t" + e.toString() + "\n\nWhat would you like to do? \n(1)Send Messege," + " (2)Add to Mail List,"
                    + " (3)Edit," + " (4)Delete," + " (5)See Messeges" + " (6)Go Back");
            
            if (!in.hasNextInt()) {
                System.out.println("Not a valid option");
                empFound(e, employeeStoreList, currentUser, mailServer);
            }            
            switch (in.nextInt()) {
                case 1:
                    customMessege = createNewMessage(currentUser, e, mailServer);
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    customMessege = employeeStoreList.addToMailList(e.getEmailAddress());
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 3:
                    editEmp(e, employeeStoreList, currentUser, mailServer);
                    break;
                case 4:
                    customMessege = employeeStoreList.delEmployee(e.getId());
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 5:
                    ArrayList<Message> found = mailServer.getMessagesFrom(e.getEmailAddress());
                    found.addAll(mailServer.getMessagesTo(e.getEmailAddress()));
                    mailFound(found, "All Messages involving " + e.getEmailAddress(), 3, employeeStoreList, mailServer, currentUser, 0);
                    break;
                case 6:
                    adminMenu("\nYou have been returned to the admin menu", employeeStoreList, currentUser, mailServer);
                    break;
                default:
                    adminMenu("\nYou have been returned to the admin menu", employeeStoreList, currentUser, mailServer);
                    break;
            }
        } 
        else {
            System.out.println("\nEmployee found,"
                    + "\t\t" + e.toStringNoSal() + "\n\nWhat would you like to do? \n(1)Send Messege," + " (2)Add to Mail List,"
                    + " (3)Go Back");
            switch (in.nextInt()) {
                case 1:
                    customMessege = createNewMessage(currentUser, e, mailServer);
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    customMessege = employeeStoreList.addToMailList(e.getEmailAddress());
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 3:
                    userMenu("\nYou have been returned to the user menu", employeeStoreList, currentUser, mailServer);
                    break;
                default:
                    userMenu("\nYou have been returned to the user menu", employeeStoreList, currentUser, mailServer);
                    break;
            }
        }
    }
    //--------------------------------------------Many Employees found Menu------------------------------------------------

    public static void manyEmpsFound(ArrayList<Employee> employeesFound, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer, int sort, String customMessage) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("\n " + customMessage + "\n");
        ArrayList<Long> foundIds = new ArrayList<>();
        int option = 1;
        String heading = String.format("%-6s %-30s %-20s %-40s %-40s %-20s", "\tID", "Name", "BirthDate", "E-mail", "Phone Number", "Type");
        System.out.println(heading);
        
        for (int i = 0; i < employeesFound.size(); i++) {
            System.out.println("\n(" + option + ")\t" + employeesFound.get(i).toListString());
            foundIds.add(employeesFound.get(i).getId());
            option++;
        }
        System.out.println("\nEnter option number of message you wish to select or press (" + (option) + ") to exit, Press (0) to change the sort.");
        int choice;
        boolean valid = false;
        if (!in.hasNextInt()) {
            System.out.println("Not a valid option");
            manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, customMessage);
        } 
        else {
            choice = in.nextInt();
            if (choice == 0) {
                sort++;
                switch (sort) {
                    case 1:
                        Collections.sort(employeesFound, (a, b) -> a.getName().compareToIgnoreCase(b.getName()));
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by name Ascending");
                        break;
                    case 2:
                        Collections.sort(employeesFound, (a, b) -> b.getName().compareToIgnoreCase(a.getName()));
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by name Decending");
                        break;
                    case 3:
                        Collections.sort(employeesFound, (a, b) -> Long.valueOf(a.getId()).compareTo(b.getId()));
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by ID Ascending");
                        break;
                    case 4:
                        Collections.sort(employeesFound, (a, b) -> Long.valueOf(b.getId()).compareTo(a.getId()));
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by ID Decending");
                        break;
                    case 5:
                        Collections.sort(employeesFound, (a, b) -> a.getEmailAddress().compareToIgnoreCase(b.getEmailAddress()));
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by Email Ascending");
                        break;
                    case 6:
                        Collections.sort(employeesFound, (a, b) -> b.getEmailAddress().compareToIgnoreCase(a.getEmailAddress()));
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by Email Decending");
                        break;
                    case 7:
                        Collections.sort(employeesFound, (a, b) -> a.getName().compareToIgnoreCase(b.getName()));
                        sort = 1;
                        manyEmpsFound(employeesFound, employeeStoreList, currentUser, mailServer, sort, "sorted by name Ascending");
                        break;
                    default:
                        break;
                }
            }
            while (choice < 0 || choice > option) {
                System.out.println("\nNot a valid choice, Please choose the option number from the list");
                choice = in.nextInt();
            }
            if (choice == (option)) {
                if (currentUser.isAdmin()) {
                    adminMenu("\nYou have been returned to the admin menu", employeeStoreList, currentUser, mailServer);
                } 
                else {
                    userMenu("\nYou have been returned to the user menu", employeeStoreList, currentUser, mailServer);
                }
            }
            if (choice > 0 && choice < option) {
                choice = choice - 1;
                Long choiceId = foundIds.get(choice);
                empFound(employeeStoreList.FindEmpById(choiceId), employeeStoreList, currentUser, mailServer);
            }
        }
    }

    //--------------------------------------------Edit Employee Menu------------------------------------------------
    public static void editEmp(Employee e, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        String customMessege;
        System.out.println(" Edit Employee Menu"
                + "\n(Employee details)\t" + e.toString()
                + "\nOptions" + "\t(1)Edit name," + " (2)Edit phone,"
                + " (3)Edit Email," + " (4)Edit Birth date,(5) Go Back (6) Update Wages");

        long id = e.getId();
        if (in.hasNextInt()) {
            
            switch (in.nextInt()) {
                case 1:
                    customMessege = employeeStoreList.editEmployeeName(id);
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    customMessege = employeeStoreList.editEmployeePhone(id);
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 3:
                    customMessege = employeeStoreList.editEmployeeEmail(id);
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 4:
                    customMessege = employeeStoreList.editEmployeeBirthDate(id);
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                    break;
                case 5:
                    empFound(e, employeeStoreList, currentUser, mailServer);
                    break;
                case 6:
                    editwages(e, employeeStoreList, currentUser, mailServer);
                    break;
                default:
                    break;
            }
        } 
        else {
            System.out.println("Not a valid option");
            editEmp(e, employeeStoreList, currentUser, mailServer);
        }
    }

    public static void editwages(Employee e, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        String customMessege;
        String customMessege2;
        long id = e.getId();
        
        if (e.getEmployeeType().equals("Agent")) {
            customMessege = employeeStoreList.editAgentSalery(id);
            adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
        } 
        else {
            customMessege = employeeStoreList.editContractorHours(id);
            customMessege2 = employeeStoreList.editContractorRate(id);
            adminMenu(customMessege + customMessege2, employeeStoreList, currentUser, mailServer);
        }
    }

    //--------------------------------------------Confirm program exit------------------------------------------------
    public static void confirmExit(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("Are you sure you want to exit? (Y/N)"
                + "\nAll details from this session will be added to a text file.");
        String input;
        input = in.next();
        
        if (input.equalsIgnoreCase("n")) {
            String customMessege = "\nNot done yet, You have been returned to the Menu";
            if (currentUser.isAdmin()) {
                adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
            } 
            else {
                userMenu(customMessege, employeeStoreList, currentUser, mailServer);
            }
        } 
        else if (input.equalsIgnoreCase("y")) {
            employeeStoreList.saveNewFile();
            mailServer.saveNewMessageFile();
            System.out.println("Goodbye :)");
        } 
        else {
            String customMessege = "\nSorry I didnt quite get that, You have been returned to the Menu";
            if (currentUser.isAdmin()) {
                adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
            } 
            else {
                userMenu(customMessege, employeeStoreList, currentUser, mailServer);
            }
        }
    }

    //--------------------------------------------Search Employee Methods------------------------------------------------
    public static void searchEmpName(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        String customMessege;
        Scanner in = new Scanner(System.in);
        System.out.println("\nPlease enter Employee name");
        String searchName = in.nextLine().trim();
        ArrayList<Employee> found = employeeStoreList.FindName(searchName);
        
        if (found.size() > 1) {
            manyEmpsFound(found, employeeStoreList, currentUser, mailServer, 0, "Employees Found");
        } 
        else if (found.size() == 1) {
            empFound(found.get(0), employeeStoreList, currentUser, mailServer);
        } 
        else {
            customMessege = "\nNo Employees found";
            if (currentUser.isAdmin()) {
                adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
            } 
            else {
                userMenu(customMessege, employeeStoreList, currentUser, mailServer);
            }
        }
    }

    public static void searchEmpEmail(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        String customMessege;
        Scanner in = new Scanner(System.in);
        System.out.println("\nPlease enter Employee E-mail Address");
        String search = in.next();

        if (!employeeStoreList.checkEmailUnique(search)) {
            Employee found = employeeStoreList.FindEmpByEmail(search);
            empFound(found, employeeStoreList, currentUser, mailServer);
        } 
        else {
            customMessege = "\nNo Employees found";
            if (currentUser.isAdmin()) {
                adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
            } 
            else {
                userMenu(customMessege, employeeStoreList, currentUser, mailServer);
            }
        }
    }

    public static void searchEmpId(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {

        Scanner in = new Scanner(System.in);
        System.out.println("\nPlease enter Employee ID");
        if (in.hasNextInt()) {
            long search = in.nextInt();
            boolean idExists = employeeStoreList.checkIdExists(search);
            
            if (idExists) {
                empFound(employeeStoreList.FindEmpById(search), employeeStoreList, currentUser, mailServer);
            } 
            else {
                String customMessege = "\nNo such ID has been found";
                if (currentUser.isAdmin()) {
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                } 
                else {
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                }
            }
        } 
        else {
            System.out.println("Not a valid option");
            searchEmpId(employeeStoreList, currentUser, mailServer);
        }
    }

    public static void searchEmpPhone(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("\nPlease enter Employee Phone number");
        String customMessege;
        if (in.hasNextInt()) {
            String search = in.next();
            ArrayList<Employee> found = employeeStoreList.FindEmpByPhone(search);
            if (found.size() > 1) {
                manyEmpsFound(found, employeeStoreList, currentUser, mailServer, 0, "Employees Found");
            } 
            else if (found.size() == 1) {
                empFound(found.get(0), employeeStoreList, currentUser, mailServer);
            } 
            else {
                customMessege = "\nNo Employees found";
                if (currentUser.isAdmin()) {
                    adminMenu(customMessege, employeeStoreList, currentUser, mailServer);
                } 
                else {
                    userMenu(customMessege, employeeStoreList, currentUser, mailServer);
                }
            }
        } else {
            System.out.println("Not a valid option");
            searchEmpPhone(employeeStoreList, currentUser, mailServer);
        }
    }

    //--------------------------------------------Get recipient for new messege------------------------------------------------
    public static void getRecipient(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("please choose a message recipient"
                + "\n (1)Search, (2) Enter Email, (3)Send To Mail List, (4)Exit");
        
        if (in.hasNextInt()) {
            int choice = in.nextInt();
            switch (choice) {
                case 1:
                    searchEmp(employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    System.out.println("Please enter email address");
                    Boolean addressNotExist = true;
                    while (addressNotExist) {
                        String recipientEmail = in.next();
                        addressNotExist = employeeStoreList.checkEmailUnique(recipientEmail);
                        if (addressNotExist) {
                            System.out.println("Sorry, I couldnt find that address please try again.");
                        } 
                        else {
                            String customMessage = createNewMessage(currentUser, employeeStoreList.FindEmpByEmail(recipientEmail), mailServer);
                            mailServer.saveNewMessageFile();
                            userMenu(customMessage, employeeStoreList, currentUser, mailServer);
                        }
                    }
                    break;
                case 3:
                    String customMessage = createNewMessageMany(currentUser, employeeStoreList.getMailList(), mailServer);
                    mailServer.saveNewMessageFile();
                    userMenu(customMessage, employeeStoreList, currentUser, mailServer);
                    break;
                case 4:
                    userMenu("Returned To User Menu", employeeStoreList, currentUser, mailServer);
                    break;
                default:
                    System.out.println("\nI'm sorry, I didn't quite get that, please try again");
                    getRecipient(employeeStoreList, currentUser, mailServer);
                    break;
            }
        } 
        else {
            System.out.println("\nI'm sorry, I didn't quite get that, please try again");
            getRecipient(employeeStoreList, currentUser, mailServer);
        }
    }

    public static ZonedDateTime getDate() {
        Scanner in = new Scanner(System.in);
        int date;
        boolean valid;
        int[] fullDate = new int[3];
        for (int i = 0; i < 3; i++) {

            do {
                if (i == 0) {
                    System.out.print("Day :");
                }
                if (i == 1) {
                    System.out.print("Month :");
                }
                if (i == 2) {
                    System.out.print("Year :");
                }
                if (!in.hasNextInt()) {
                    System.out.println("Not A Valid Choice");
                    getDate();
                }
                date = in.nextInt();
                valid = valiDate(i, date);
            } while (!valid);
            fullDate[i] = date;
        }
        return ZonedDateTime.of(fullDate[2], fullDate[1], fullDate[0], 0, 0, 0, 0, ZoneId.of("Europe/Dublin"));
    }

    public static  ZonedDateTime currentDate() {
        ZonedDateTime timestamp = ZonedDateTime.now();
        return timestamp;
    }

    public static ZonedDateTime currentDateLessX(int x) {
        ZonedDateTime timestamp = ZonedDateTime.now().minusDays(x);
        return timestamp;
    }

    public static String formatDate(ZonedDateTime d) {
        DateTimeFormatter dtf = DateTimeFormatter.RFC_1123_DATE_TIME ;
        String date = dtf.format(d); 
        return date;
    }

    public static boolean valiDate(int i, int date) {
        boolean valid = true;
        
        if (i == 0 && (date < 1 || date > 31)) {
            valid = false;
            System.out.println("Please enter a valid date");
        } 
        else if (i == 1 && (date < 1 || date > 12)) {
            valid = false;
            System.out.println("Please enter a valid date");
        } 
        else if (i == 2 && (date < 1900 || date > 2017)) {
            valid = false;
            System.out.println("Please enter a valid date");
        }
        return valid;
    }

    public static String createNewMessage(Employee currentUser, Employee recipient, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        String sender = currentUser.getEmailAddress();
        ArrayList<String> recipients = new ArrayList<>();
        recipients.add(recipient.getEmailAddress());
        ZonedDateTime date = currentDate();
        ZonedDateTime timestamp = ZonedDateTime.now();
        String strTimestamp = DateTimeFormatter.RFC_1123_DATE_TIME.format(timestamp);

        String priority = selectPriority();
        System.out.println("Please Enter the subject");
        String subject = in.nextLine();
        System.out.println("\nNew E-mail\n");
        String head = String.format("%-40s %-25s %-10s", "To : " + recipient.getEmailAddress(), "Priority : " + priority, strTimestamp);
        System.out.println(head + "\nSubject : " + subject);

        System.out.println("\nPlease type your message below, then press enter to send");
        String body = in.nextLine();

        Message m = new Message(sender, recipients, subject, date, priority, body);
        mailServer.addMessage(m);
        mailServer.saveNewMessageFile();

        return "\n***Message Sent***";
    }

    public static String createNewMessageMany(Employee currentUser, ArrayList<String> recipients, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        String sender = currentUser.getEmailAddress();
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < recipients.size(); i++) {
            out.append(recipients.get(i)).append(",");
        }
        ZonedDateTime date = currentDate();
        String priority = selectPriority();
        System.out.println("Please Enter the subject");
        String subject = in.nextLine();
        ZonedDateTime timestamp = ZonedDateTime.now();
        String strTimestamp = DateTimeFormatter.RFC_1123_DATE_TIME.format(timestamp);

        System.out.println("\nNew E-mail\n");
        String head = String.format("%-40s %-25s %-10s", "To : " + out, "Priority : " + priority, strTimestamp);
        System.out.println(head + "\nSubject : " + subject);

        System.out.println("\nPlease type your message below then press enter to send");
        String body = in.nextLine();

        Message m = new Message(sender, recipients, subject, date, priority, body);
        mailServer.addMessage(m);
        mailServer.saveNewMessageFile();

        return "\n***Message Sent***";
    }

    public static String selectPriority() {
        Scanner in = new Scanner(System.in);
        String priority = null;
        System.out.println("please select the Priority"
                + "\n(1)low, (2)Medium, (3)High");
        if (!in.hasNextInt()) {
            System.out.println("Not A Valid Choice");
            selectPriority();
        } else {
            int choice = in.nextInt();
            in.nextLine();
            switch (choice) {
                case 1:
                    priority = "Low";
                    break;
                case 2:
                    priority = "Medium";
                    break;
                case 3:
                    priority = "High";
                    break;
                default:
                    System.out.println("Not a valid choice, Please try again");
                    selectPriority();
                    break;
            }
        }
        return priority;
    }

    //--------------------------------------------List files in directery------------------------------------------------
    public static void listFiles() {
        File dir = new File(".");
        for (File file : dir.listFiles()) {
            if (file.getName().endsWith((".txt"))) {
                System.out.println("Files : " + file.getName());
            }
        }
    }

    public static void searchMail(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("Search mail by \n(1)Sender, (2)Reciever, (3)date, (4)Keyword, (5)ID, (6)Priority, (7)Show All, (8)Advance search (9)Exit");
        
        if (!in.hasNextInt()) {
            System.out.println("Not A Valid Choice");
            searchMail(employeeStoreList, currentUser, mailServer);
        } 
        else {
            int choice = in.nextInt();
            in.nextLine();
            switch (choice) {
                case 1:
                    //search mail sender
                    System.out.println("What's the sender's email address?");
                    String sender = in.next();
                    mailFound(mailServer.getMessagesFrom(sender), "Displaying all Employee Mail From : " + sender, 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 2:
                    //search reciever
                    System.out.println("What's the email address?");
                    String receiver = in.next();
                    mailFound(mailServer.getMessagesTo(receiver), "Displaying all Employee Mail To : " + receiver, 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 3:
                    System.out.println("Please enter the date");
                    ZonedDateTime date = getDate();
                    mailFound(mailServer.getMessagesDate(date), "Displaying all Employee Mail Sent On : " + date.getDayOfMonth() + "//" + date.getMonthValue() + "//" + date.getYear(), 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 4:
                    //search by subject
                    System.out.println("Please enter the word you wish to search");
                    String Search;
                    Search = in.nextLine();
                    mailFound(mailServer.listMessageByKeyword(Search), "Displaying all Employee Mail That Contains : " + Search, 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 5:
                    //search by Id
                    long id;
                    System.out.println("\nPlease enter Message ID");
                    id = in.nextLong();
                    viewMessage(mailServer.getAllMessages(), mailServer.returnMessageFromID(id), employeeStoreList, currentUser, mailServer, 3);//3 is display option
                    break;
                case 6:
                    String priority = selectPriority();
                    mailFound(mailServer.getMessagesPriority(priority), "Displaying all Employee Mail With Priority : " + priority, 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 7:
                    mailFound(mailServer.getAllMessages(), "Displaying all Employee Mail", 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 8:
                    advanceSearchMail(employeeStoreList, currentUser, mailServer);
                    break;
                default:
                    adminMenu("Returned to Admin menu", employeeStoreList, currentUser, mailServer);
                    break;
            }
        }
    }

    public static void advanceSearchMail(Employee_store employeeStoreList, Employee currentUser, messageStore mailServer) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println("Search mail by \n(1)Sent Between Dates, (2)Sent From Between Two Dates , (3)Show All Sent In the Last X Days (4)Exit");
        if (!in.hasNextInt()) {
            System.out.println("Not A Valid Choice");
            advanceSearchMail(employeeStoreList, currentUser, mailServer);
        } else {
            int choice = in.nextInt();
            in.nextLine();

            switch (choice) {
                case 1:
                    //search mail sender
                    System.out.println("Please enter the date sent after");
                    ZonedDateTime afterDate = getDate();
                    System.out.println("Please enter the date sent before");
                    ZonedDateTime beforeDate = getDate();
                    String customMessage = "Displaying all Employee Mail between : " + formatDate(afterDate) + " and " + formatDate(beforeDate);
                    mailFound(mailServer.getMessagesBetweenDate(afterDate, beforeDate), customMessage, 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                case 2:
                    //search reciever
                    System.out.println("What's the email address?");
                    String sender = in.next();
                    System.out.println("Please enter the date sent after");
                    afterDate = getDate();
                    System.out.println("Please enter the date sent before");
                    beforeDate = getDate();
                    customMessage = "Displaying all Employee Mail Sent by : " + sender + "\nBetween" + formatDate(afterDate) + " and " + formatDate(beforeDate);
                    ArrayList<Message> between = mailServer.getMessagesBetweenDate(afterDate, beforeDate);
                    mailFound(mailServer.getMessagesFromBetween(sender, between), customMessage, 3, employeeStoreList, mailServer, currentUser, 3);

                    break;
                case 3:
                    //mail sent in the last x days
                    System.out.println("Please enter the amount of days to view");
                    int days = in.nextInt();
                    afterDate = currentDateLessX(days);
                    beforeDate = currentDate();
                    System.out.println(formatDate(afterDate) + " and " + formatDate(beforeDate));
                    customMessage = "Displaying all Employee Mail Sent in the last " + days + " days";
                    mailFound(mailServer.getMessagesBetweenDate(afterDate, beforeDate), customMessage, 3, employeeStoreList, mailServer, currentUser, 3);
                    break;
                default:
                    adminMenu("Returned to Admin menu", employeeStoreList, currentUser, mailServer);
                    break;
            }
        }
    }

    //--------------------------------------------mail found Menu------------------------------------------------
    public static void mailFound(ArrayList<Message> mesagesFound, String customMessage, int displayOption, Employee_store employeeStoreList, messageStore mailServer, Employee currentUser, int sort) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        if (mesagesFound.size() < 1) {
            System.out.println("No mail found :(");
        }
        ArrayList<Long> foundIds = new ArrayList<>();
        int option = 1;
        switch (displayOption) {
            case 1:

                customMessage = String.format("\n" + customMessage + "\n   \t%-40s %-40s %-10s", "From", "Subject", "Date");
                System.out.println(customMessage);
                break;
            case 2:

                customMessage = String.format("\n" + customMessage + "\n   \t%-40s %-40s %-10s", "To", "Subject", "Date");
                System.out.println(customMessage);
                break;
            default:

                customMessage = String.format("\n" + customMessage + "\n   \t%-40s %-40s %-40s %-10s", "From", "To", "Subject", "Date");
                System.out.println(customMessage);
                break;
        }
        for (int i = 0; i < mesagesFound.size(); i++) {
            switch (displayOption) {
                case 1:

                    System.out.println("\n(" + (option) + ")\t" + mesagesFound.get(i).toInboxString());
                    break;
                case 2:
                    System.out.println("\n(" + (option) + ")\t" + mesagesFound.get(i).toOutboxString());
                    break;
                default:
                    System.out.println("\n(" + (option) + ")\t" + mesagesFound.get(i).toAllString());
                    break;
            }
            foundIds.add(mesagesFound.get(i).getMessageID());
            option++;
        }
        System.out.println("\nEnter option number of message you wish to select or press (" + (option) + ") to exit, Press (0) to change the sort.");
        int count = 0;
        int choice;
        boolean valid = false;
        if (!in.hasNextInt()) {
            mailFound(mesagesFound, "Not A Valid Choice", displayOption, employeeStoreList, mailServer, currentUser, sort);
        } 
        else {
            choice = in.nextInt();
            while (choice < -1 || choice > option + 1) {
                System.out.println("\nNot a valid choice, Please choose the option number from the list");
                choice = in.nextInt();
            }

            // The folowing code will check if the user is in the inbox, outbox or view all mode and cycle through the sort order differently for each displayoption
            if (choice == 0) {
                sort++;
                switch (sort) {
                    case 1:
                        switch (displayOption) {
                            case 1:
                                Collections.sort(mesagesFound, (a, b) -> a.getFromAddress().compareToIgnoreCase(b.getFromAddress()));
                                customMessage = "\nSorted by sender Acending";
                                break;
                            case 2:
                                Collections.sort(mesagesFound, (a, b) -> a.getToFirstAddress().compareToIgnoreCase(b.getToFirstAddress()));
                                customMessage = "\nSorted by recipient Acending";
                                break;
                            default:
                                Collections.sort(mesagesFound, (a, b) -> a.getFromAddress().compareToIgnoreCase(b.getFromAddress()));
                                customMessage = "\nSorted by sender Acending";
                                break;
                        }
                        mailFound(mesagesFound, customMessage, displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 2:
                        switch (displayOption) {
                            case 1:
                                Collections.sort(mesagesFound, (a, b) -> b.getFromAddress().compareToIgnoreCase(a.getFromAddress()));
                                customMessage = "\nSorted by sender Decending";
                                break;
                            case 2:
                                Collections.sort(mesagesFound, (a, b) -> b.getToFirstAddress().compareToIgnoreCase(a.getToFirstAddress()));
                                customMessage = "\nSorted by recipient Decending";
                                break;
                            default:
                                Collections.sort(mesagesFound, (a, b) -> b.getFromAddress().compareToIgnoreCase(a.getFromAddress()));
                                sort = 7;
                                customMessage = "\nSorted by sender Decending";
                                break;
                        }
                        mailFound(mesagesFound, customMessage, displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 3:
                        Collections.sort(mesagesFound, (a, b) -> b.getDateDay() - a.getDateDay());
                        Collections.sort(mesagesFound, (a, b) -> b.getDateMonth() - a.getDateMonth());
                        Collections.sort(mesagesFound, (a, b) -> b.getDateYear() - a.getDateYear());
                        mailFound(mesagesFound, "\nSorted by Date Decending", displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 4:
                        Collections.sort(mesagesFound, (a, b) -> a.getDateDay() - b.getDateDay());
                        Collections.sort(mesagesFound, (a, b) -> a.getDateMonth() - b.getDateMonth());
                        Collections.sort(mesagesFound, (a, b) -> a.getDateYear() - b.getDateYear());

                        mailFound(mesagesFound, "\nSorted by Date Acending", displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 5:
                        Collections.sort(mesagesFound, (a, b) -> Long.valueOf(a.getMessageID()).compareTo(b.getMessageID()));
                        mailFound(mesagesFound, "\nSorted by ID Acending", displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 6:
                        Collections.sort(mesagesFound, (a, b) -> Long.valueOf(b.getMessageID()).compareTo(a.getMessageID()));
                        mailFound(mesagesFound, "\nSorted by ID Decending", displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 7:
                        switch (displayOption) {
                            case 1:
                                Collections.sort(mesagesFound, (a, b) -> a.getFromAddress().compareToIgnoreCase(b.getFromAddress()));
                                customMessage = "\nSorted by sender Acending";
                                break;
                            case 2:
                                Collections.sort(mesagesFound, (a, b) -> a.getToFirstAddress().compareToIgnoreCase(b.getToFirstAddress()));
                                customMessage = "\nSorted by recipient Acending";
                                break;
                            default:
                                Collections.sort(mesagesFound, (a, b) -> a.getFromAddress().compareToIgnoreCase(b.getFromAddress()));
                                customMessage = "\nSorted by sender Acending";
                                break;
                        }
                        sort = 1;
                        mailFound(mesagesFound, customMessage, displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 8:
                        Collections.sort(mesagesFound, (a, b) -> a.getToFirstAddress().compareToIgnoreCase(b.getToFirstAddress()));
                        customMessage = "\nSorted by recipient Acending";
                        mailFound(mesagesFound, customMessage, displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    case 9:
                        Collections.sort(mesagesFound, (a, b) -> b.getToFirstAddress().compareToIgnoreCase(a.getToFirstAddress()));
                        customMessage = "\nSorted by recipient Decending";
                        sort = 2;
                        mailFound(mesagesFound, customMessage, displayOption, employeeStoreList, mailServer, currentUser, sort);
                        break;
                    default:
                        break;
                }
            }
            if (choice == (option)) {
                if (currentUser.isAdmin()) {
                    adminMenu("\nYou have been returned to the admin menu", employeeStoreList, currentUser, mailServer);
                } 
                else {
                    userMenu("\nYou have been returned to the user menu", employeeStoreList, currentUser, mailServer);
                }
            } 
            else if ((choice >= 1 && choice < option)) {
                choice = choice - 1;
                Long choiceId = foundIds.get(choice);
                viewMessage(mesagesFound, mailServer.returnMessageFromID(choiceId), employeeStoreList, currentUser, mailServer, displayOption);
            }
        }
    }

    public static void viewMessage(ArrayList<Message> mesagesFound, Message m, Employee_store employeeStoreList, Employee currentUser, messageStore mailServer, int displayOption) throws FileNotFoundException {
        Scanner in = new Scanner(System.in);
        System.out.println(m.ViewMessage());
        System.out.println("(1)Reply, (2)Go Back");
        
        if (!in.hasNextInt()) {
            System.out.println("Not A Valid Choice");
            viewMessage(mesagesFound, m, employeeStoreList, currentUser, mailServer, displayOption);
        } 
        else {
            int choice = in.nextInt();
            switch (choice) {
                case 1:
                    String customMessage = createNewMessage(currentUser, employeeStoreList.FindEmpByEmail(m.getFromAddress()), mailServer);
                    userMenu(customMessage, employeeStoreList, currentUser, mailServer);
                    break;
                case 2:
                    mailFound(mesagesFound, "gone back", displayOption, employeeStoreList, mailServer, currentUser, 1);
                    break;
                default:
                    System.out.println("\nSorry I didnt quite get that, Please try again");
                    viewMessage(mesagesFound, m, employeeStoreList, currentUser, mailServer, displayOption);
                    break;
            }
        }
    }
}



